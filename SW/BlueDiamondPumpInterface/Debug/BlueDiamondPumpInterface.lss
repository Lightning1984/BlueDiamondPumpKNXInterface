
BlueDiamondPumpInterface.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  000006fc  00000790  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003c  00800062  00800062  00000792  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000792  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000007c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000090  00000000  00000000  00000800  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000849  00000000  00000000  00000890  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000026a  00000000  00000000  000010d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000369  00000000  00000000  00001343  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001a8  00000000  00000000  000016ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000036e  00000000  00000000  00001854  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004d1  00000000  00000000  00001bc2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000080  00000000  00000000  00002093  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	28 c0       	rjmp	.+80     	; 0x54 <__bad_interrupt>
   4:	27 c0       	rjmp	.+78     	; 0x54 <__bad_interrupt>
   6:	26 c0       	rjmp	.+76     	; 0x54 <__bad_interrupt>
   8:	25 c0       	rjmp	.+74     	; 0x54 <__bad_interrupt>
   a:	dd c2       	rjmp	.+1466   	; 0x5c6 <__vector_5>
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	99 c2       	rjmp	.+1330   	; 0x544 <__vector_8>
  12:	20 c0       	rjmp	.+64     	; 0x54 <__bad_interrupt>
  14:	1f c0       	rjmp	.+62     	; 0x54 <__bad_interrupt>
  16:	1e c0       	rjmp	.+60     	; 0x54 <__bad_interrupt>
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>

0000001e <__ctors_end>:
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf e5       	ldi	r28, 0x5F	; 95
  24:	d2 e0       	ldi	r29, 0x02	; 2
  26:	de bf       	out	0x3e, r29	; 62
  28:	cd bf       	out	0x3d, r28	; 61

0000002a <__do_copy_data>:
  2a:	10 e0       	ldi	r17, 0x00	; 0
  2c:	a0 e6       	ldi	r26, 0x60	; 96
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	ec ef       	ldi	r30, 0xFC	; 252
  32:	f6 e0       	ldi	r31, 0x06	; 6
  34:	02 c0       	rjmp	.+4      	; 0x3a <__do_copy_data+0x10>
  36:	05 90       	lpm	r0, Z+
  38:	0d 92       	st	X+, r0
  3a:	a2 36       	cpi	r26, 0x62	; 98
  3c:	b1 07       	cpc	r27, r17
  3e:	d9 f7       	brne	.-10     	; 0x36 <__do_copy_data+0xc>

00000040 <__do_clear_bss>:
  40:	20 e0       	ldi	r18, 0x00	; 0
  42:	a2 e6       	ldi	r26, 0x62	; 98
  44:	b0 e0       	ldi	r27, 0x00	; 0
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
  4a:	ae 39       	cpi	r26, 0x9E	; 158
  4c:	b2 07       	cpc	r27, r18
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
  50:	fd d2       	rcall	.+1530   	; 0x64c <main>
  52:	52 c3       	rjmp	.+1700   	; 0x6f8 <_exit>

00000054 <__bad_interrupt>:
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <state_pwroff>:
	uint8_t pWrite;
	uint8_t pRead;
} chan2_buffer = {{}, 0, 0}; //Init circular buffer struct to zero

void state_pwroff(uint8_t * stateflags){
	if (!(*stateflags & 1<<STATEPOWEROFF)){ //Entry Event --> Pump was Power Switched off
  56:	fc 01       	movw	r30, r24
  58:	20 81       	ld	r18, Z
  5a:	20 fd       	sbrc	r18, 0
  5c:	05 c0       	rjmp	.+10     	; 0x68 <state_pwroff+0x12>
		*stateflags = 1<<STATEPOWEROFF;
  5e:	21 e0       	ldi	r18, 0x01	; 1
  60:	20 83       	st	Z, r18
		OUTPORT &= ~((1<<OUT1)|(1<<OUT2));
  62:	88 b3       	in	r24, 0x18	; 24
  64:	8c 7f       	andi	r24, 0xFC	; 252
  66:	88 bb       	out	0x18, r24	; 24
	}
	if(p_myavgdata->chan1last2avg>PUMPPWRDOWN && p_myavgdata->chan2last2avg>ALARMPWRDOWN){ //Power on Event occurred
  68:	e0 91 60 00 	lds	r30, 0x0060
  6c:	f0 91 61 00 	lds	r31, 0x0061
  70:	80 81       	ld	r24, Z
  72:	91 81       	ldd	r25, Z+1	; 0x01
  74:	89 3c       	cpi	r24, 0xC9	; 201
  76:	91 05       	cpc	r25, r1
  78:	58 f0       	brcs	.+22     	; 0x90 <state_pwroff+0x3a>
  7a:	82 81       	ldd	r24, Z+2	; 0x02
  7c:	93 81       	ldd	r25, Z+3	; 0x03
  7e:	89 3c       	cpi	r24, 0xC9	; 201
  80:	91 05       	cpc	r25, r1
  82:	30 f0       	brcs	.+12     	; 0x90 <state_pwroff+0x3a>
		statehandler = state_training; //Switch state to Training
  84:	87 e1       	ldi	r24, 0x17	; 23
  86:	92 e0       	ldi	r25, 0x02	; 2
  88:	90 93 9a 00 	sts	0x009A, r25
  8c:	80 93 99 00 	sts	0x0099, r24
  90:	08 95       	ret

00000092 <Chan1BufferIn>:
}



uint8_t Chan1BufferIn(uint16_t data)
{
  92:	9c 01       	movw	r18, r24
	uint8_t next = ((chan1_buffer.pWrite + 1) & CHAN1_BUFFER_MASK);
  94:	a8 e7       	ldi	r26, 0x78	; 120
  96:	b0 e0       	ldi	r27, 0x00	; 0
  98:	50 96       	adiw	r26, 0x10	; 16
  9a:	9c 91       	ld	r25, X
  9c:	50 97       	sbiw	r26, 0x10	; 16
  9e:	9f 5f       	subi	r25, 0xFF	; 255
  a0:	97 70       	andi	r25, 0x07	; 7
	chan1_buffer.data[chan1_buffer.pWrite] = data;
  a2:	50 96       	adiw	r26, 0x10	; 16
  a4:	ec 91       	ld	r30, X
  a6:	50 97       	sbiw	r26, 0x10	; 16
  a8:	f0 e0       	ldi	r31, 0x00	; 0
  aa:	ee 0f       	add	r30, r30
  ac:	ff 1f       	adc	r31, r31
  ae:	e8 58       	subi	r30, 0x88	; 136
  b0:	ff 4f       	sbci	r31, 0xFF	; 255
  b2:	31 83       	std	Z+1, r19	; 0x01
  b4:	20 83       	st	Z, r18
	chan1_buffer.pRead = chan1_buffer.pWrite; //We want to know were to get the most recent value
  b6:	50 96       	adiw	r26, 0x10	; 16
  b8:	8c 91       	ld	r24, X
  ba:	50 97       	sbiw	r26, 0x10	; 16
  bc:	51 96       	adiw	r26, 0x11	; 17
  be:	8c 93       	st	X, r24
  c0:	51 97       	sbiw	r26, 0x11	; 17
	chan1_buffer.pWrite = next; //Where to write next time
  c2:	50 96       	adiw	r26, 0x10	; 16
  c4:	9c 93       	st	X, r25
	return BUFFER_SUCCESS;
}
  c6:	81 e0       	ldi	r24, 0x01	; 1
  c8:	08 95       	ret

000000ca <Chan1BufferOut>:

uint16_t Chan1BufferOut(int8_t position){ //0 to -7
	if ((int8_t)chan1_buffer.pRead + position >= 0){
  ca:	20 91 89 00 	lds	r18, 0x0089
  ce:	08 2e       	mov	r0, r24
  d0:	00 0c       	add	r0, r0
  d2:	99 0b       	sbc	r25, r25
  d4:	ac 01       	movw	r20, r24
  d6:	42 0f       	add	r20, r18
  d8:	51 1d       	adc	r21, r1
  da:	27 fd       	sbrc	r18, 7
  dc:	5a 95       	dec	r21
  de:	55 23       	and	r21, r21
  e0:	74 f0       	brlt	.+28     	; 0xfe <Chan1BufferOut+0x34>
		return chan1_buffer.data[(int8_t)chan1_buffer.pRead + position];
  e2:	20 91 89 00 	lds	r18, 0x0089
  e6:	fc 01       	movw	r30, r24
  e8:	e2 0f       	add	r30, r18
  ea:	f1 1d       	adc	r31, r1
  ec:	27 fd       	sbrc	r18, 7
  ee:	fa 95       	dec	r31
  f0:	ee 0f       	add	r30, r30
  f2:	ff 1f       	adc	r31, r31
  f4:	e8 58       	subi	r30, 0x88	; 136
  f6:	ff 4f       	sbci	r31, 0xFF	; 255
  f8:	80 81       	ld	r24, Z
  fa:	91 81       	ldd	r25, Z+1	; 0x01
  fc:	08 95       	ret
	}
	else{
		return chan1_buffer.data[((int8_t)chan1_buffer.pRead + position)+8];
  fe:	20 91 89 00 	lds	r18, 0x0089
 102:	fc 01       	movw	r30, r24
 104:	e2 0f       	add	r30, r18
 106:	f1 1d       	adc	r31, r1
 108:	27 fd       	sbrc	r18, 7
 10a:	fa 95       	dec	r31
 10c:	ee 0f       	add	r30, r30
 10e:	ff 1f       	adc	r31, r31
 110:	e8 57       	subi	r30, 0x78	; 120
 112:	ff 4f       	sbci	r31, 0xFF	; 255
 114:	80 81       	ld	r24, Z
 116:	91 81       	ldd	r25, Z+1	; 0x01
	}
}
 118:	08 95       	ret

0000011a <Chan2BufferIn>:

uint8_t Chan2BufferIn(uint16_t data)
{
 11a:	9c 01       	movw	r18, r24
	uint8_t next = ((chan2_buffer.pWrite + 1) & CHAN2_BUFFER_MASK);
 11c:	a6 e6       	ldi	r26, 0x66	; 102
 11e:	b0 e0       	ldi	r27, 0x00	; 0
 120:	50 96       	adiw	r26, 0x10	; 16
 122:	9c 91       	ld	r25, X
 124:	50 97       	sbiw	r26, 0x10	; 16
 126:	9f 5f       	subi	r25, 0xFF	; 255
 128:	97 70       	andi	r25, 0x07	; 7
	chan2_buffer.data[chan2_buffer.pWrite] = data;
 12a:	50 96       	adiw	r26, 0x10	; 16
 12c:	ec 91       	ld	r30, X
 12e:	50 97       	sbiw	r26, 0x10	; 16
 130:	f0 e0       	ldi	r31, 0x00	; 0
 132:	ee 0f       	add	r30, r30
 134:	ff 1f       	adc	r31, r31
 136:	ea 59       	subi	r30, 0x9A	; 154
 138:	ff 4f       	sbci	r31, 0xFF	; 255
 13a:	31 83       	std	Z+1, r19	; 0x01
 13c:	20 83       	st	Z, r18
	chan2_buffer.pRead = chan2_buffer.pWrite; //We want to know were to get the most recent value
 13e:	50 96       	adiw	r26, 0x10	; 16
 140:	8c 91       	ld	r24, X
 142:	50 97       	sbiw	r26, 0x10	; 16
 144:	51 96       	adiw	r26, 0x11	; 17
 146:	8c 93       	st	X, r24
 148:	51 97       	sbiw	r26, 0x11	; 17
	chan2_buffer.pWrite = next; //Where to write next time
 14a:	50 96       	adiw	r26, 0x10	; 16
 14c:	9c 93       	st	X, r25
	return BUFFER_SUCCESS;
}
 14e:	81 e0       	ldi	r24, 0x01	; 1
 150:	08 95       	ret

00000152 <Chan2BufferOut>:

uint16_t Chan2BufferOut(int8_t position){ //0 to -7
	if ((int8_t)chan2_buffer.pRead + position >= 0){
 152:	20 91 77 00 	lds	r18, 0x0077
 156:	08 2e       	mov	r0, r24
 158:	00 0c       	add	r0, r0
 15a:	99 0b       	sbc	r25, r25
 15c:	ac 01       	movw	r20, r24
 15e:	42 0f       	add	r20, r18
 160:	51 1d       	adc	r21, r1
 162:	27 fd       	sbrc	r18, 7
 164:	5a 95       	dec	r21
 166:	55 23       	and	r21, r21
 168:	74 f0       	brlt	.+28     	; 0x186 <Chan2BufferOut+0x34>
		return chan2_buffer.data[(int8_t)chan2_buffer.pRead + position];
 16a:	20 91 77 00 	lds	r18, 0x0077
 16e:	fc 01       	movw	r30, r24
 170:	e2 0f       	add	r30, r18
 172:	f1 1d       	adc	r31, r1
 174:	27 fd       	sbrc	r18, 7
 176:	fa 95       	dec	r31
 178:	ee 0f       	add	r30, r30
 17a:	ff 1f       	adc	r31, r31
 17c:	ea 59       	subi	r30, 0x9A	; 154
 17e:	ff 4f       	sbci	r31, 0xFF	; 255
 180:	80 81       	ld	r24, Z
 182:	91 81       	ldd	r25, Z+1	; 0x01
 184:	08 95       	ret
	}
	else{
		return chan2_buffer.data[((int8_t)chan2_buffer.pRead + position)+8];
 186:	20 91 77 00 	lds	r18, 0x0077
 18a:	fc 01       	movw	r30, r24
 18c:	e2 0f       	add	r30, r18
 18e:	f1 1d       	adc	r31, r1
 190:	27 fd       	sbrc	r18, 7
 192:	fa 95       	dec	r31
 194:	ee 0f       	add	r30, r30
 196:	ff 1f       	adc	r31, r31
 198:	ea 58       	subi	r30, 0x8A	; 138
 19a:	ff 4f       	sbci	r31, 0xFF	; 255
 19c:	80 81       	ld	r24, Z
 19e:	91 81       	ldd	r25, Z+1	; 0x01
	}
}
 1a0:	08 95       	ret

000001a2 <state_idle>:
	else if (p_myavgdata->chan1last2avg<=PUMPONVAL && (millis()-stateentrytime>TRAININGTOUT)){
		statehandler = state_pumping;		//Switch state to Pumping
	}
}
void state_idle(uint8_t * stateflags){
	if (!(*stateflags & 1<<STATEIDLE)){ //Entry Event --> Pump transitioned to idle
 1a2:	fc 01       	movw	r30, r24
 1a4:	20 81       	ld	r18, Z
 1a6:	22 fd       	sbrc	r18, 2
 1a8:	02 c0       	rjmp	.+4      	; 0x1ae <state_idle+0xc>
		*stateflags = 1<<STATEIDLE;
 1aa:	24 e0       	ldi	r18, 0x04	; 4
 1ac:	20 83       	st	Z, r18
	}
	if(Chan1BufferOut(0)<PUMPPWRDOWN && Chan2BufferOut(0)<ALARMPWRDOWN){
 1ae:	80 e0       	ldi	r24, 0x00	; 0
 1b0:	8c df       	rcall	.-232    	; 0xca <Chan1BufferOut>
 1b2:	88 3c       	cpi	r24, 0xC8	; 200
 1b4:	91 05       	cpc	r25, r1
 1b6:	60 f4       	brcc	.+24     	; 0x1d0 <state_idle+0x2e>
 1b8:	80 e0       	ldi	r24, 0x00	; 0
 1ba:	cb df       	rcall	.-106    	; 0x152 <Chan2BufferOut>
 1bc:	88 3c       	cpi	r24, 0xC8	; 200
 1be:	91 05       	cpc	r25, r1
 1c0:	38 f4       	brcc	.+14     	; 0x1d0 <state_idle+0x2e>
		statehandler = state_pwroff;
 1c2:	8b e2       	ldi	r24, 0x2B	; 43
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	90 93 9a 00 	sts	0x009A, r25
 1ca:	80 93 99 00 	sts	0x0099, r24
 1ce:	08 95       	ret
	}
	else if(p_myavgdata->chan2last2avg<p_myavgdata->chan2first4avg && p_myavgdata->chan2last2avg<=ALARMONVAL){ //Alarm Event occurred
 1d0:	e0 91 60 00 	lds	r30, 0x0060
 1d4:	f0 91 61 00 	lds	r31, 0x0061
 1d8:	22 81       	ldd	r18, Z+2	; 0x02
 1da:	33 81       	ldd	r19, Z+3	; 0x03
 1dc:	86 81       	ldd	r24, Z+6	; 0x06
 1de:	97 81       	ldd	r25, Z+7	; 0x07
 1e0:	28 17       	cp	r18, r24
 1e2:	39 07       	cpc	r19, r25
 1e4:	78 f4       	brcc	.+30     	; 0x204 <state_idle+0x62>
 1e6:	82 81       	ldd	r24, Z+2	; 0x02
 1e8:	93 81       	ldd	r25, Z+3	; 0x03
 1ea:	8a 34       	cpi	r24, 0x4A	; 74
 1ec:	92 40       	sbci	r25, 0x02	; 2
 1ee:	50 f4       	brcc	.+20     	; 0x204 <state_idle+0x62>
		OUTPORT |= ((1<<OUT1)|(1<<OUT2));	//Enable Pumping and Alarm
 1f0:	88 b3       	in	r24, 0x18	; 24
 1f2:	83 60       	ori	r24, 0x03	; 3
 1f4:	88 bb       	out	0x18, r24	; 24
		statehandler = state_alarm;			//Switch state to Alarm
 1f6:	8b e5       	ldi	r24, 0x5B	; 91
 1f8:	91 e0       	ldi	r25, 0x01	; 1
 1fa:	90 93 9a 00 	sts	0x009A, r25
 1fe:	80 93 99 00 	sts	0x0099, r24
 202:	08 95       	ret
	}
	else if(p_myavgdata->chan1last2avg<p_myavgdata->chan1first4avg && p_myavgdata->chan1last2avg<=PUMPONVAL){ //Pumping event occurred
 204:	20 81       	ld	r18, Z
 206:	31 81       	ldd	r19, Z+1	; 0x01
 208:	84 81       	ldd	r24, Z+4	; 0x04
 20a:	95 81       	ldd	r25, Z+5	; 0x05
 20c:	28 17       	cp	r18, r24
 20e:	39 07       	cpc	r19, r25
 210:	60 f4       	brcc	.+24     	; 0x22a <state_idle+0x88>
 212:	80 81       	ld	r24, Z
 214:	91 81       	ldd	r25, Z+1	; 0x01
 216:	80 34       	cpi	r24, 0x40	; 64
 218:	92 40       	sbci	r25, 0x02	; 2
 21a:	38 f4       	brcc	.+14     	; 0x22a <state_idle+0x88>
		OUTPORT |= (1<<OUT1);				//Enable Pumping
 21c:	c1 9a       	sbi	0x18, 1	; 24
		statehandler = state_pumping;		//Switch state to Pumping
 21e:	86 e1       	ldi	r24, 0x16	; 22
 220:	91 e0       	ldi	r25, 0x01	; 1
 222:	90 93 9a 00 	sts	0x009A, r25
 226:	80 93 99 00 	sts	0x0099, r24
 22a:	08 95       	ret

0000022c <state_pumping>:
	}
	
}

void state_pumping(uint8_t * stateflags){
	if (!(*stateflags & 1<<STATEPUMPING)){ //Entry Event --> Pump transitioned to Pumping
 22c:	fc 01       	movw	r30, r24
 22e:	20 81       	ld	r18, Z
 230:	23 fd       	sbrc	r18, 3
 232:	02 c0       	rjmp	.+4      	; 0x238 <state_pumping+0xc>
		*stateflags = 1<<STATEPUMPING;
 234:	28 e0       	ldi	r18, 0x08	; 8
 236:	20 83       	st	Z, r18
	}
	if(Chan1BufferOut(0)<PUMPPWRDOWN && Chan2BufferOut(0)<ALARMPWRDOWN){
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	47 df       	rcall	.-370    	; 0xca <Chan1BufferOut>
 23c:	88 3c       	cpi	r24, 0xC8	; 200
 23e:	91 05       	cpc	r25, r1
 240:	60 f4       	brcc	.+24     	; 0x25a <state_pumping+0x2e>
 242:	80 e0       	ldi	r24, 0x00	; 0
 244:	86 df       	rcall	.-244    	; 0x152 <Chan2BufferOut>
 246:	88 3c       	cpi	r24, 0xC8	; 200
 248:	91 05       	cpc	r25, r1
 24a:	38 f4       	brcc	.+14     	; 0x25a <state_pumping+0x2e>
		statehandler = state_pwroff;
 24c:	8b e2       	ldi	r24, 0x2B	; 43
 24e:	90 e0       	ldi	r25, 0x00	; 0
 250:	90 93 9a 00 	sts	0x009A, r25
 254:	80 93 99 00 	sts	0x0099, r24
 258:	08 95       	ret
	}
	else if(p_myavgdata->chan2last2avg<p_myavgdata->chan2first4avg && p_myavgdata->chan2last2avg<=ALARMONVAL){ //Alarm Event occurred
 25a:	e0 91 60 00 	lds	r30, 0x0060
 25e:	f0 91 61 00 	lds	r31, 0x0061
 262:	22 81       	ldd	r18, Z+2	; 0x02
 264:	33 81       	ldd	r19, Z+3	; 0x03
 266:	86 81       	ldd	r24, Z+6	; 0x06
 268:	97 81       	ldd	r25, Z+7	; 0x07
 26a:	28 17       	cp	r18, r24
 26c:	39 07       	cpc	r19, r25
 26e:	78 f4       	brcc	.+30     	; 0x28e <__stack+0x2f>
 270:	82 81       	ldd	r24, Z+2	; 0x02
 272:	93 81       	ldd	r25, Z+3	; 0x03
 274:	8a 34       	cpi	r24, 0x4A	; 74
 276:	92 40       	sbci	r25, 0x02	; 2
 278:	50 f4       	brcc	.+20     	; 0x28e <__stack+0x2f>
		OUTPORT |= ((1<<OUT1)|(1<<OUT2));	//Enable Pumping and Alarm
 27a:	88 b3       	in	r24, 0x18	; 24
 27c:	83 60       	ori	r24, 0x03	; 3
 27e:	88 bb       	out	0x18, r24	; 24
		statehandler = state_alarm;			//Switch state to Alarm
 280:	8b e5       	ldi	r24, 0x5B	; 91
 282:	91 e0       	ldi	r25, 0x01	; 1
 284:	90 93 9a 00 	sts	0x009A, r25
 288:	80 93 99 00 	sts	0x0099, r24
 28c:	08 95       	ret
	}
	else if(p_myavgdata->chan1last2avg>p_myavgdata->chan1first4avg && p_myavgdata->chan1last2avg>=PUMPOFFVAL){ //Idle event occurred
 28e:	20 81       	ld	r18, Z
 290:	31 81       	ldd	r19, Z+1	; 0x01
 292:	84 81       	ldd	r24, Z+4	; 0x04
 294:	95 81       	ldd	r25, Z+5	; 0x05
 296:	82 17       	cp	r24, r18
 298:	93 07       	cpc	r25, r19
 29a:	60 f4       	brcc	.+24     	; 0x2b4 <__stack+0x55>
 29c:	80 81       	ld	r24, Z
 29e:	91 81       	ldd	r25, Z+1	; 0x01
 2a0:	82 36       	cpi	r24, 0x62	; 98
 2a2:	92 40       	sbci	r25, 0x02	; 2
 2a4:	38 f0       	brcs	.+14     	; 0x2b4 <__stack+0x55>
		OUTPORT &= ~(1<<OUT1);				//Disable Pumping
 2a6:	c1 98       	cbi	0x18, 1	; 24
		statehandler = state_idle;			//Switch state to Idle
 2a8:	81 ed       	ldi	r24, 0xD1	; 209
 2aa:	90 e0       	ldi	r25, 0x00	; 0
 2ac:	90 93 9a 00 	sts	0x009A, r25
 2b0:	80 93 99 00 	sts	0x0099, r24
 2b4:	08 95       	ret

000002b6 <state_alarm>:
	}
	
}

void state_alarm(uint8_t * stateflags){
	if (!(*stateflags & 1<<STATEALARM)){ //Entry Event --> Pump transitioned to Alarm
 2b6:	fc 01       	movw	r30, r24
 2b8:	20 81       	ld	r18, Z
 2ba:	24 fd       	sbrc	r18, 4
 2bc:	02 c0       	rjmp	.+4      	; 0x2c2 <state_alarm+0xc>
		*stateflags = 1<<STATEALARM;
 2be:	20 e1       	ldi	r18, 0x10	; 16
 2c0:	20 83       	st	Z, r18
	}
	if(Chan1BufferOut(0)<PUMPPWRDOWN && Chan2BufferOut(0)<ALARMPWRDOWN){
 2c2:	80 e0       	ldi	r24, 0x00	; 0
 2c4:	02 df       	rcall	.-508    	; 0xca <Chan1BufferOut>
 2c6:	88 3c       	cpi	r24, 0xC8	; 200
 2c8:	91 05       	cpc	r25, r1
 2ca:	60 f4       	brcc	.+24     	; 0x2e4 <state_alarm+0x2e>
 2cc:	80 e0       	ldi	r24, 0x00	; 0
 2ce:	41 df       	rcall	.-382    	; 0x152 <Chan2BufferOut>
 2d0:	88 3c       	cpi	r24, 0xC8	; 200
 2d2:	91 05       	cpc	r25, r1
 2d4:	38 f4       	brcc	.+14     	; 0x2e4 <state_alarm+0x2e>
		statehandler = state_pwroff;
 2d6:	8b e2       	ldi	r24, 0x2B	; 43
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	90 93 9a 00 	sts	0x009A, r25
 2de:	80 93 99 00 	sts	0x0099, r24
 2e2:	08 95       	ret
	}
	else if(p_myavgdata->chan2last2avg>p_myavgdata->chan2first4avg && p_myavgdata->chan2last2avg>=ALARMOFFVAL){ //Alarm Cleared
 2e4:	e0 91 60 00 	lds	r30, 0x0060
 2e8:	f0 91 61 00 	lds	r31, 0x0061
 2ec:	22 81       	ldd	r18, Z+2	; 0x02
 2ee:	33 81       	ldd	r19, Z+3	; 0x03
 2f0:	86 81       	ldd	r24, Z+6	; 0x06
 2f2:	97 81       	ldd	r25, Z+7	; 0x07
 2f4:	82 17       	cp	r24, r18
 2f6:	93 07       	cpc	r25, r19
 2f8:	60 f4       	brcc	.+24     	; 0x312 <state_alarm+0x5c>
 2fa:	82 81       	ldd	r24, Z+2	; 0x02
 2fc:	93 81       	ldd	r25, Z+3	; 0x03
 2fe:	8c 36       	cpi	r24, 0x6C	; 108
 300:	92 40       	sbci	r25, 0x02	; 2
 302:	38 f0       	brcs	.+14     	; 0x312 <state_alarm+0x5c>
		OUTPORT &= ~(1<<OUT2);				//Disable Alarm
 304:	c0 98       	cbi	0x18, 0	; 24
		statehandler = state_pumping;		//Switch state to Alarm
 306:	86 e1       	ldi	r24, 0x16	; 22
 308:	91 e0       	ldi	r25, 0x01	; 1
 30a:	90 93 9a 00 	sts	0x009A, r25
 30e:	80 93 99 00 	sts	0x0099, r24
 312:	08 95       	ret

00000314 <ProcessData>:
	else{
		return chan2_buffer.data[((int8_t)chan2_buffer.pRead + position)+8];
	}
}

void ProcessData(avgdata * p_myavgdata){
 314:	0f 93       	push	r16
 316:	1f 93       	push	r17
 318:	cf 93       	push	r28
 31a:	df 93       	push	r29
 31c:	8c 01       	movw	r16, r24
	p_myavgdata->chan1last2avg = ((Chan1BufferOut(0) + Chan1BufferOut(-1)) / 2);
 31e:	80 e0       	ldi	r24, 0x00	; 0
 320:	d4 de       	rcall	.-600    	; 0xca <Chan1BufferOut>
 322:	ec 01       	movw	r28, r24
 324:	8f ef       	ldi	r24, 0xFF	; 255
 326:	d1 de       	rcall	.-606    	; 0xca <Chan1BufferOut>
 328:	8c 0f       	add	r24, r28
 32a:	9d 1f       	adc	r25, r29
 32c:	96 95       	lsr	r25
 32e:	87 95       	ror	r24
 330:	f8 01       	movw	r30, r16
 332:	91 83       	std	Z+1, r25	; 0x01
 334:	80 83       	st	Z, r24
	p_myavgdata->chan2last2avg = ((Chan2BufferOut(0) + Chan2BufferOut(-1)) / 2);
 336:	80 e0       	ldi	r24, 0x00	; 0
 338:	0c df       	rcall	.-488    	; 0x152 <Chan2BufferOut>
 33a:	ec 01       	movw	r28, r24
 33c:	8f ef       	ldi	r24, 0xFF	; 255
 33e:	09 df       	rcall	.-494    	; 0x152 <Chan2BufferOut>
 340:	8c 0f       	add	r24, r28
 342:	9d 1f       	adc	r25, r29
 344:	96 95       	lsr	r25
 346:	87 95       	ror	r24
 348:	f8 01       	movw	r30, r16
 34a:	93 83       	std	Z+3, r25	; 0x03
 34c:	82 83       	std	Z+2, r24	; 0x02
	p_myavgdata->chan1first4avg = ((Chan1BufferOut(-7) + Chan1BufferOut(-6) + Chan1BufferOut(-5) + Chan1BufferOut(-4)) / 4);
 34e:	89 ef       	ldi	r24, 0xF9	; 249
 350:	bc de       	rcall	.-648    	; 0xca <Chan1BufferOut>
 352:	ec 01       	movw	r28, r24
 354:	8a ef       	ldi	r24, 0xFA	; 250
 356:	b9 de       	rcall	.-654    	; 0xca <Chan1BufferOut>
 358:	c8 0f       	add	r28, r24
 35a:	d9 1f       	adc	r29, r25
 35c:	8b ef       	ldi	r24, 0xFB	; 251
 35e:	b5 de       	rcall	.-662    	; 0xca <Chan1BufferOut>
 360:	c8 0f       	add	r28, r24
 362:	d9 1f       	adc	r29, r25
 364:	8c ef       	ldi	r24, 0xFC	; 252
 366:	b1 de       	rcall	.-670    	; 0xca <Chan1BufferOut>
 368:	8c 0f       	add	r24, r28
 36a:	9d 1f       	adc	r25, r29
 36c:	96 95       	lsr	r25
 36e:	87 95       	ror	r24
 370:	96 95       	lsr	r25
 372:	87 95       	ror	r24
 374:	f8 01       	movw	r30, r16
 376:	95 83       	std	Z+5, r25	; 0x05
 378:	84 83       	std	Z+4, r24	; 0x04
	p_myavgdata->chan2first4avg = ((Chan2BufferOut(-7) + Chan2BufferOut(-6) + Chan2BufferOut(-5) + Chan2BufferOut(-4)) / 4);
 37a:	89 ef       	ldi	r24, 0xF9	; 249
 37c:	ea de       	rcall	.-556    	; 0x152 <Chan2BufferOut>
 37e:	ec 01       	movw	r28, r24
 380:	8a ef       	ldi	r24, 0xFA	; 250
 382:	e7 de       	rcall	.-562    	; 0x152 <Chan2BufferOut>
 384:	c8 0f       	add	r28, r24
 386:	d9 1f       	adc	r29, r25
 388:	8b ef       	ldi	r24, 0xFB	; 251
 38a:	e3 de       	rcall	.-570    	; 0x152 <Chan2BufferOut>
 38c:	c8 0f       	add	r28, r24
 38e:	d9 1f       	adc	r29, r25
 390:	8c ef       	ldi	r24, 0xFC	; 252
 392:	df de       	rcall	.-578    	; 0x152 <Chan2BufferOut>
 394:	8c 0f       	add	r24, r28
 396:	9d 1f       	adc	r25, r29
 398:	ec 01       	movw	r28, r24
 39a:	d6 95       	lsr	r29
 39c:	c7 95       	ror	r28
 39e:	d6 95       	lsr	r29
 3a0:	c7 95       	ror	r28
 3a2:	f8 01       	movw	r30, r16
 3a4:	d7 83       	std	Z+7, r29	; 0x07
 3a6:	c6 83       	std	Z+6, r28	; 0x06

}
 3a8:	df 91       	pop	r29
 3aa:	cf 91       	pop	r28
 3ac:	1f 91       	pop	r17
 3ae:	0f 91       	pop	r16
 3b0:	08 95       	ret

000003b2 <MuxChannel>:

uint8_t MuxChannel(uint8_t channel){
	
	if (channel==ANALOG1){
 3b2:	83 30       	cpi	r24, 0x03	; 3
 3b4:	41 f4       	brne	.+16     	; 0x3c6 <MuxChannel+0x14>
		//MUX set to PB3
		ADMUX |= ((1<<MUX1)|(1<<MUX0)); 
 3b6:	87 b1       	in	r24, 0x07	; 7
 3b8:	83 60       	ori	r24, 0x03	; 3
 3ba:	87 b9       	out	0x07, r24	; 7
		ADMUX &= ~((1<<MUX3)|(1<<MUX2));
 3bc:	87 b1       	in	r24, 0x07	; 7
 3be:	83 7f       	andi	r24, 0xF3	; 243
 3c0:	87 b9       	out	0x07, r24	; 7
		return ANALOG1;
 3c2:	83 e0       	ldi	r24, 0x03	; 3
 3c4:	08 95       	ret
	}
	else if (channel==ANALOG2){
 3c6:	84 30       	cpi	r24, 0x04	; 4
 3c8:	31 f4       	brne	.+12     	; 0x3d6 <MuxChannel+0x24>
		//MUX set to PB4
		ADMUX |= ((1<<MUX1)); 
 3ca:	39 9a       	sbi	0x07, 1	; 7
		ADMUX &= ~((1<<MUX3)|(1<<MUX2)|(1<<MUX0));
 3cc:	87 b1       	in	r24, 0x07	; 7
 3ce:	82 7f       	andi	r24, 0xF2	; 242
 3d0:	87 b9       	out	0x07, r24	; 7
		return ANALOG2;
 3d2:	84 e0       	ldi	r24, 0x04	; 4
 3d4:	08 95       	ret
	}
	else if (channel==BANDGAP){
 3d6:	8d 3f       	cpi	r24, 0xFD	; 253
 3d8:	41 f4       	brne	.+16     	; 0x3ea <MuxChannel+0x38>
		//MUX set to internal Bandgap reference (should read 1.1V)
		ADMUX |= ((1<<MUX3)|(1<<MUX2));
 3da:	87 b1       	in	r24, 0x07	; 7
 3dc:	8c 60       	ori	r24, 0x0C	; 12
 3de:	87 b9       	out	0x07, r24	; 7
		ADMUX &= ~((1<<MUX1)|(1<<MUX0)); 
 3e0:	87 b1       	in	r24, 0x07	; 7
 3e2:	8c 7f       	andi	r24, 0xFC	; 252
 3e4:	87 b9       	out	0x07, r24	; 7
		return BANDGAP;
 3e6:	8d ef       	ldi	r24, 0xFD	; 253
 3e8:	08 95       	ret
	}
	else if (channel==QUERY){ //Used to query the current setting
 3ea:	8f 3f       	cpi	r24, 0xFF	; 255
 3ec:	71 f4       	brne	.+28     	; 0x40a <MuxChannel+0x58>
		if ((ADMUX & 0x0f) == ((1<<MUX1)|(1<<MUX0))){
 3ee:	87 b1       	in	r24, 0x07	; 7
 3f0:	8f 70       	andi	r24, 0x0F	; 15
 3f2:	83 30       	cpi	r24, 0x03	; 3
 3f4:	79 f0       	breq	.+30     	; 0x414 <MuxChannel+0x62>
			return ANALOG1;
		}
		else if ((ADMUX & 0x0f) == (1<<MUX1)) {
 3f6:	87 b1       	in	r24, 0x07	; 7
 3f8:	8f 70       	andi	r24, 0x0F	; 15
 3fa:	82 30       	cpi	r24, 0x02	; 2
 3fc:	41 f0       	breq	.+16     	; 0x40e <MuxChannel+0x5c>
			return ANALOG2;
		}
		else if ((ADMUX & 0x0f) == ((1<<MUX3)|(1<<MUX2))) {
 3fe:	87 b1       	in	r24, 0x07	; 7
 400:	8f 70       	andi	r24, 0x0F	; 15
 402:	8c 30       	cpi	r24, 0x0C	; 12
 404:	31 f0       	breq	.+12     	; 0x412 <MuxChannel+0x60>
			return BANDGAP;
		}
		else {
			return 0xff;
 406:	8f ef       	ldi	r24, 0xFF	; 255
 408:	08 95       	ret
		}
		
	}
	else {
		return 0xff;
 40a:	8f ef       	ldi	r24, 0xFF	; 255
 40c:	08 95       	ret
	else if (channel==QUERY){ //Used to query the current setting
		if ((ADMUX & 0x0f) == ((1<<MUX1)|(1<<MUX0))){
			return ANALOG1;
		}
		else if ((ADMUX & 0x0f) == (1<<MUX1)) {
			return ANALOG2;
 40e:	84 e0       	ldi	r24, 0x04	; 4
 410:	08 95       	ret
		}
		else if ((ADMUX & 0x0f) == ((1<<MUX3)|(1<<MUX2))) {
			return BANDGAP;
 412:	8d ef       	ldi	r24, 0xFD	; 253
		
	}
	else {
		return 0xff;
	}
}
 414:	08 95       	ret

00000416 <millis>:

//Atomic access to the millis timer
uint32_t millis() {
  uint32_t m;
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 416:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 418:	f8 94       	cli
	  m = _millis;	  
 41a:	60 91 8c 00 	lds	r22, 0x008C
 41e:	70 91 8d 00 	lds	r23, 0x008D
 422:	80 91 8e 00 	lds	r24, 0x008E
 426:	90 91 8f 00 	lds	r25, 0x008F
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 42a:	2f bf       	out	0x3f, r18	; 63
  }
  return m;
}
 42c:	08 95       	ret

0000042e <state_training>:
	}
	if(p_myavgdata->chan1last2avg>PUMPPWRDOWN && p_myavgdata->chan2last2avg>ALARMPWRDOWN){ //Power on Event occurred
		statehandler = state_training; //Switch state to Training
	}
}
void state_training(uint8_t * stateflags){
 42e:	0f 93       	push	r16
 430:	1f 93       	push	r17
 432:	cf 93       	push	r28
 434:	df 93       	push	r29
 436:	ec 01       	movw	r28, r24
	static uint32_t stateentrytime;
	if (!(*stateflags & 1<<STATETRAINING)){ //Entry Event --> Pump Power Switched on
 438:	88 81       	ld	r24, Y
 43a:	81 fd       	sbrc	r24, 1
 43c:	0c c0       	rjmp	.+24     	; 0x456 <state_training+0x28>
		stateentrytime = millis();
 43e:	eb df       	rcall	.-42     	; 0x416 <millis>
 440:	60 93 62 00 	sts	0x0062, r22
 444:	70 93 63 00 	sts	0x0063, r23
 448:	80 93 64 00 	sts	0x0064, r24
 44c:	90 93 65 00 	sts	0x0065, r25
		OUTPORT |= (1<<OUT1);				//Enable Pumping
 450:	c1 9a       	sbi	0x18, 1	; 24
		*stateflags = 1<<STATETRAINING;
 452:	82 e0       	ldi	r24, 0x02	; 2
 454:	88 83       	st	Y, r24
	}
	if(Chan1BufferOut(0)<PUMPPWRDOWN && Chan2BufferOut(0)<ALARMPWRDOWN){
 456:	80 e0       	ldi	r24, 0x00	; 0
 458:	38 de       	rcall	.-912    	; 0xca <Chan1BufferOut>
 45a:	88 3c       	cpi	r24, 0xC8	; 200
 45c:	91 05       	cpc	r25, r1
 45e:	60 f4       	brcc	.+24     	; 0x478 <state_training+0x4a>
 460:	80 e0       	ldi	r24, 0x00	; 0
 462:	77 de       	rcall	.-786    	; 0x152 <Chan2BufferOut>
 464:	88 3c       	cpi	r24, 0xC8	; 200
 466:	91 05       	cpc	r25, r1
 468:	38 f4       	brcc	.+14     	; 0x478 <state_training+0x4a>
			statehandler = state_pwroff;
 46a:	8b e2       	ldi	r24, 0x2B	; 43
 46c:	90 e0       	ldi	r25, 0x00	; 0
 46e:	90 93 9a 00 	sts	0x009A, r25
 472:	80 93 99 00 	sts	0x0099, r24
 476:	61 c0       	rjmp	.+194    	; 0x53a <state_training+0x10c>
	}
	else if(((p_myavgdata->chan1last2avg>PUMPOFFVAL) && (p_myavgdata->chan2last2avg>ALARMOFFVAL))){ //Power on Event occurred
 478:	e0 91 60 00 	lds	r30, 0x0060
 47c:	f0 91 61 00 	lds	r31, 0x0061
 480:	80 81       	ld	r24, Z
 482:	91 81       	ldd	r25, Z+1	; 0x01
 484:	83 36       	cpi	r24, 0x63	; 99
 486:	92 40       	sbci	r25, 0x02	; 2
 488:	68 f0       	brcs	.+26     	; 0x4a4 <state_training+0x76>
 48a:	82 81       	ldd	r24, Z+2	; 0x02
 48c:	93 81       	ldd	r25, Z+3	; 0x03
 48e:	8d 36       	cpi	r24, 0x6D	; 109
 490:	92 40       	sbci	r25, 0x02	; 2
 492:	40 f0       	brcs	.+16     	; 0x4a4 <state_training+0x76>
		OUTPORT &= ~(1<<OUT1);				//Disable Pumping
 494:	c1 98       	cbi	0x18, 1	; 24
		statehandler = state_idle;			//Switch state to Idle
 496:	81 ed       	ldi	r24, 0xD1	; 209
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	90 93 9a 00 	sts	0x009A, r25
 49e:	80 93 99 00 	sts	0x0099, r24
 4a2:	4b c0       	rjmp	.+150    	; 0x53a <state_training+0x10c>
	}
	else if (p_myavgdata->chan1last2avg<=PUMPONVAL && p_myavgdata->chan2last2avg<=ALARMONVAL && (millis()-stateentrytime>TRAININGTOUT)){
 4a4:	80 81       	ld	r24, Z
 4a6:	91 81       	ldd	r25, Z+1	; 0x01
 4a8:	80 34       	cpi	r24, 0x40	; 64
 4aa:	92 40       	sbci	r25, 0x02	; 2
 4ac:	18 f5       	brcc	.+70     	; 0x4f4 <state_training+0xc6>
 4ae:	82 81       	ldd	r24, Z+2	; 0x02
 4b0:	93 81       	ldd	r25, Z+3	; 0x03
 4b2:	8a 34       	cpi	r24, 0x4A	; 74
 4b4:	92 40       	sbci	r25, 0x02	; 2
 4b6:	f0 f4       	brcc	.+60     	; 0x4f4 <state_training+0xc6>
 4b8:	ae df       	rcall	.-164    	; 0x416 <millis>
 4ba:	00 91 62 00 	lds	r16, 0x0062
 4be:	10 91 63 00 	lds	r17, 0x0063
 4c2:	20 91 64 00 	lds	r18, 0x0064
 4c6:	30 91 65 00 	lds	r19, 0x0065
 4ca:	dc 01       	movw	r26, r24
 4cc:	cb 01       	movw	r24, r22
 4ce:	80 1b       	sub	r24, r16
 4d0:	91 0b       	sbc	r25, r17
 4d2:	a2 0b       	sbc	r26, r18
 4d4:	b3 0b       	sbc	r27, r19
 4d6:	81 38       	cpi	r24, 0x81	; 129
 4d8:	9e 43       	sbci	r25, 0x3E	; 62
 4da:	a1 05       	cpc	r26, r1
 4dc:	b1 05       	cpc	r27, r1
 4de:	50 f0       	brcs	.+20     	; 0x4f4 <state_training+0xc6>
		OUTPORT |= ((1<<OUT1)|(1<<OUT2));	//Enable Pumping and Alarm
 4e0:	88 b3       	in	r24, 0x18	; 24
 4e2:	83 60       	ori	r24, 0x03	; 3
 4e4:	88 bb       	out	0x18, r24	; 24
		statehandler = state_alarm;			//Switch state to Alarm
 4e6:	8b e5       	ldi	r24, 0x5B	; 91
 4e8:	91 e0       	ldi	r25, 0x01	; 1
 4ea:	90 93 9a 00 	sts	0x009A, r25
 4ee:	80 93 99 00 	sts	0x0099, r24
 4f2:	23 c0       	rjmp	.+70     	; 0x53a <state_training+0x10c>
	}
	else if (p_myavgdata->chan1last2avg<=PUMPONVAL && (millis()-stateentrytime>TRAININGTOUT)){
 4f4:	e0 91 60 00 	lds	r30, 0x0060
 4f8:	f0 91 61 00 	lds	r31, 0x0061
 4fc:	80 81       	ld	r24, Z
 4fe:	91 81       	ldd	r25, Z+1	; 0x01
 500:	80 34       	cpi	r24, 0x40	; 64
 502:	92 40       	sbci	r25, 0x02	; 2
 504:	d0 f4       	brcc	.+52     	; 0x53a <state_training+0x10c>
 506:	87 df       	rcall	.-242    	; 0x416 <millis>
 508:	00 91 62 00 	lds	r16, 0x0062
 50c:	10 91 63 00 	lds	r17, 0x0063
 510:	20 91 64 00 	lds	r18, 0x0064
 514:	30 91 65 00 	lds	r19, 0x0065
 518:	dc 01       	movw	r26, r24
 51a:	cb 01       	movw	r24, r22
 51c:	80 1b       	sub	r24, r16
 51e:	91 0b       	sbc	r25, r17
 520:	a2 0b       	sbc	r26, r18
 522:	b3 0b       	sbc	r27, r19
 524:	81 38       	cpi	r24, 0x81	; 129
 526:	9e 43       	sbci	r25, 0x3E	; 62
 528:	a1 05       	cpc	r26, r1
 52a:	b1 05       	cpc	r27, r1
 52c:	30 f0       	brcs	.+12     	; 0x53a <state_training+0x10c>
		statehandler = state_pumping;		//Switch state to Pumping
 52e:	86 e1       	ldi	r24, 0x16	; 22
 530:	91 e0       	ldi	r25, 0x01	; 1
 532:	90 93 9a 00 	sts	0x009A, r25
 536:	80 93 99 00 	sts	0x0099, r24
	}
}
 53a:	df 91       	pop	r29
 53c:	cf 91       	pop	r28
 53e:	1f 91       	pop	r17
 540:	0f 91       	pop	r16
 542:	08 95       	ret

00000544 <__vector_8>:
  }
  return m;
}

//ISR for ADC conversion complete
ISR(ADC_vect){
 544:	1f 92       	push	r1
 546:	0f 92       	push	r0
 548:	0f b6       	in	r0, 0x3f	; 63
 54a:	0f 92       	push	r0
 54c:	11 24       	eor	r1, r1
 54e:	2f 93       	push	r18
 550:	3f 93       	push	r19
 552:	4f 93       	push	r20
 554:	5f 93       	push	r21
 556:	6f 93       	push	r22
 558:	7f 93       	push	r23
 55a:	8f 93       	push	r24
 55c:	9f 93       	push	r25
 55e:	af 93       	push	r26
 560:	bf 93       	push	r27
 562:	cf 93       	push	r28
 564:	ef 93       	push	r30
 566:	ff 93       	push	r31
	uint8_t lowbyte=ADCL;
 568:	c4 b1       	in	r28, 0x04	; 4
	if(MuxChannel(QUERY)==ANALOG1){ //if we are currently measuring the first channel
 56a:	8f ef       	ldi	r24, 0xFF	; 255
 56c:	22 df       	rcall	.-444    	; 0x3b2 <MuxChannel>
 56e:	83 30       	cpi	r24, 0x03	; 3
 570:	49 f4       	brne	.+18     	; 0x584 <__vector_8+0x40>
		Chan1BufferIn(ADCH<<8 | lowbyte);
 572:	25 b1       	in	r18, 0x05	; 5
 574:	8c 2f       	mov	r24, r28
 576:	90 e0       	ldi	r25, 0x00	; 0
 578:	92 2b       	or	r25, r18
 57a:	8b dd       	rcall	.-1258   	; 0x92 <Chan1BufferIn>
		MuxChannel(ANALOG2); //Switch to Second Channel
 57c:	84 e0       	ldi	r24, 0x04	; 4
 57e:	19 df       	rcall	.-462    	; 0x3b2 <MuxChannel>
		ADCSRA |= (1 << ADSC); //Start next ADC Measurement
 580:	36 9a       	sbi	0x06, 6	; 6
 582:	0a c0       	rjmp	.+20     	; 0x598 <__vector_8+0x54>
	}
	else if(MuxChannel(QUERY)==ANALOG2){ //we are currently measuring the second channel
 584:	8f ef       	ldi	r24, 0xFF	; 255
 586:	15 df       	rcall	.-470    	; 0x3b2 <MuxChannel>
 588:	84 30       	cpi	r24, 0x04	; 4
 58a:	31 f4       	brne	.+12     	; 0x598 <__vector_8+0x54>
		Chan2BufferIn(ADCH<<8 | lowbyte);
 58c:	25 b1       	in	r18, 0x05	; 5
 58e:	8c 2f       	mov	r24, r28
 590:	90 e0       	ldi	r25, 0x00	; 0
 592:	92 2b       	or	r25, r18
 594:	c2 dd       	rcall	.-1148   	; 0x11a <Chan2BufferIn>
		adc_disable();
 596:	37 98       	cbi	0x06, 7	; 6
	}
	statusflags |= (1<<STATUSADCVALUEAVAILABLE);
 598:	80 91 9b 00 	lds	r24, 0x009B
 59c:	81 60       	ori	r24, 0x01	; 1
 59e:	80 93 9b 00 	sts	0x009B, r24
}
 5a2:	ff 91       	pop	r31
 5a4:	ef 91       	pop	r30
 5a6:	cf 91       	pop	r28
 5a8:	bf 91       	pop	r27
 5aa:	af 91       	pop	r26
 5ac:	9f 91       	pop	r25
 5ae:	8f 91       	pop	r24
 5b0:	7f 91       	pop	r23
 5b2:	6f 91       	pop	r22
 5b4:	5f 91       	pop	r21
 5b6:	4f 91       	pop	r20
 5b8:	3f 91       	pop	r19
 5ba:	2f 91       	pop	r18
 5bc:	0f 90       	pop	r0
 5be:	0f be       	out	0x3f, r0	; 63
 5c0:	0f 90       	pop	r0
 5c2:	1f 90       	pop	r1
 5c4:	18 95       	reti

000005c6 <__vector_5>:

//ISR for timer 0 Overflow (our millis counter)
ISR(TIM0_OVF_vect) {
 5c6:	1f 92       	push	r1
 5c8:	0f 92       	push	r0
 5ca:	0f b6       	in	r0, 0x3f	; 63
 5cc:	0f 92       	push	r0
 5ce:	11 24       	eor	r1, r1
 5d0:	2f 93       	push	r18
 5d2:	4f 93       	push	r20
 5d4:	5f 93       	push	r21
 5d6:	6f 93       	push	r22
 5d8:	7f 93       	push	r23
 5da:	8f 93       	push	r24
 5dc:	9f 93       	push	r25
  _1000us += 256;
 5de:	80 91 8a 00 	lds	r24, 0x008A
 5e2:	90 91 8b 00 	lds	r25, 0x008B
 5e6:	93 95       	inc	r25
 5e8:	90 93 8b 00 	sts	0x008B, r25
 5ec:	80 93 8a 00 	sts	0x008A, r24
  while (_1000us > 1000) {
 5f0:	89 3e       	cpi	r24, 0xE9	; 233
 5f2:	23 e0       	ldi	r18, 0x03	; 3
 5f4:	92 07       	cpc	r25, r18
 5f6:	f0 f0       	brcs	.+60     	; 0x634 <__vector_5+0x6e>
 5f8:	40 91 8c 00 	lds	r20, 0x008C
 5fc:	50 91 8d 00 	lds	r21, 0x008D
 600:	60 91 8e 00 	lds	r22, 0x008E
 604:	70 91 8f 00 	lds	r23, 0x008F
    _millis++;
 608:	4f 5f       	subi	r20, 0xFF	; 255
 60a:	5f 4f       	sbci	r21, 0xFF	; 255
 60c:	6f 4f       	sbci	r22, 0xFF	; 255
 60e:	7f 4f       	sbci	r23, 0xFF	; 255
    _1000us -= 1000;
 610:	88 5e       	subi	r24, 0xE8	; 232
 612:	93 40       	sbci	r25, 0x03	; 3
}

//ISR for timer 0 Overflow (our millis counter)
ISR(TIM0_OVF_vect) {
  _1000us += 256;
  while (_1000us > 1000) {
 614:	89 3e       	cpi	r24, 0xE9	; 233
 616:	23 e0       	ldi	r18, 0x03	; 3
 618:	92 07       	cpc	r25, r18
 61a:	b0 f7       	brcc	.-20     	; 0x608 <__vector_5+0x42>
 61c:	40 93 8c 00 	sts	0x008C, r20
 620:	50 93 8d 00 	sts	0x008D, r21
 624:	60 93 8e 00 	sts	0x008E, r22
 628:	70 93 8f 00 	sts	0x008F, r23
 62c:	90 93 8b 00 	sts	0x008B, r25
 630:	80 93 8a 00 	sts	0x008A, r24
    _millis++;
    _1000us -= 1000;
  }
}
 634:	9f 91       	pop	r25
 636:	8f 91       	pop	r24
 638:	7f 91       	pop	r23
 63a:	6f 91       	pop	r22
 63c:	5f 91       	pop	r21
 63e:	4f 91       	pop	r20
 640:	2f 91       	pop	r18
 642:	0f 90       	pop	r0
 644:	0f be       	out	0x3f, r0	; 63
 646:	0f 90       	pop	r0
 648:	1f 90       	pop	r1
 64a:	18 95       	reti

0000064c <main>:
__attribute__ ((__always_inline__))
void wdt_enable (const uint8_t value)
{
	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
	{
		__asm__ __volatile__ (
 64c:	9d e0       	ldi	r25, 0x0D	; 13
 64e:	88 e1       	ldi	r24, 0x18	; 24
 650:	0f b6       	in	r0, 0x3f	; 63
 652:	f8 94       	cli
 654:	a8 95       	wdr
 656:	81 bd       	out	0x21, r24	; 33
 658:	0f be       	out	0x3f, r0	; 63
 65a:	91 bd       	out	0x21, r25	; 33
{
	//Setup Watchdog for safety reset
	wdt_enable(WDTO_500MS);
	
	//Setup Digital outputs
	DDRB |= ((1<<OUT1)|(1<<OUT2)|(1<<LEDON));	//Set Pins To Output
 65c:	87 b3       	in	r24, 0x17	; 23
 65e:	87 60       	ori	r24, 0x07	; 7
 660:	87 bb       	out	0x17, r24	; 23
	PORTB &= ~((1<<OUT1)|(1<<OUT2)|(1<<LEDON));  //Set all outputs to LOW
 662:	88 b3       	in	r24, 0x18	; 24
 664:	88 7f       	andi	r24, 0xF8	; 248
 666:	88 bb       	out	0x18, r24	; 24
	#ifdef DEBUGLED
	PORTB |= (1<<LEDON); //Enable Debugging LEDs
 668:	c2 9a       	sbi	0x18, 2	; 24
	#endif
	
	//Init Analog inputs + ADC
	DDRB &= ~((1<<ANALOG1)|(1<<ANALOG2)); //Set Pins To Input
 66a:	87 b3       	in	r24, 0x17	; 23
 66c:	87 7e       	andi	r24, 0xE7	; 231
 66e:	87 bb       	out	0x17, r24	; 23
	PORTB &= ~((1<<ANALOG1)|(1<<ANALOG2)); //Set Pullup Disabled
 670:	88 b3       	in	r24, 0x18	; 24
 672:	87 7e       	andi	r24, 0xE7	; 231
 674:	88 bb       	out	0x18, r24	; 24
	ADMUX |= ((1<<REFS2)|(1<<REFS1)); //Set analog reference (Vref) to Internal 2.56V reference without external bypass capacitor
 676:	87 b1       	in	r24, 0x07	; 7
 678:	80 69       	ori	r24, 0x90	; 144
 67a:	87 b9       	out	0x07, r24	; 7
	MuxChannel(BANDGAP);
 67c:	8d ef       	ldi	r24, 0xFD	; 253
 67e:	99 de       	rcall	.-718    	; 0x3b2 <MuxChannel>
	ADCSRA |= ((1<<ADIE)|(1<<ADPS1)|(1<<ADPS0)); //Enable ADC Interrupt and set Timing Prescaler to 1/8 fCPU (125 kHz) 
 680:	86 b1       	in	r24, 0x06	; 6
 682:	8b 60       	ori	r24, 0x0B	; 11
 684:	86 b9       	out	0x06, r24	; 6

	//Init Timer
	// timer0 running at 1/1 the clock rate
	// overflow timer0 every 0.256 ms
	TCCR0B |= (1<<CS00);
 686:	83 b7       	in	r24, 0x33	; 51
 688:	81 60       	ori	r24, 0x01	; 1
 68a:	83 bf       	out	0x33, r24	; 51
	// enable timer overflow interrupt
	TIMSK  |= (1<<TOIE0);
 68c:	89 b7       	in	r24, 0x39	; 57
 68e:	82 60       	ori	r24, 0x02	; 2
 690:	89 bf       	out	0x39, r24	; 57

	// Enable global interrupts
	sei();
 692:	78 94       	sei

	// Preload now value before entering main loop
	uint32_t hundrettwetyfifemstimer = millis();
 694:	c0 de       	rcall	.-640    	; 0x416 <millis>
 696:	6b 01       	movw	r12, r22
 698:	7c 01       	movw	r14, r24
	uint8_t everysecondtime = 0;	

    //We start in the Power off State
	statehandler = state_pwroff;
 69a:	8b e2       	ldi	r24, 0x2B	; 43
 69c:	90 e0       	ldi	r25, 0x00	; 0
 69e:	90 93 9a 00 	sts	0x009A, r25
 6a2:	80 93 99 00 	sts	0x0099, r24
	// Enable global interrupts
	sei();

	// Preload now value before entering main loop
	uint32_t hundrettwetyfifemstimer = millis();
	uint8_t everysecondtime = 0;	
 6a6:	c0 e0       	ldi	r28, 0x00	; 0
				everysecondtime=0;
			}
			else{
				//handle states at even time
				statehandler(&stateflags);
				everysecondtime++;
 6a8:	11 e0       	ldi	r17, 0x01	; 1
 		if (millis()-hundrettwetyfifemstimer>125){
			hundrettwetyfifemstimer = millis(); //set time immediately after loop call, therefore function is called every 125 ms
			if (everysecondtime > 0){
				//process the data odd times
				ProcessData(p_myavgdata);
				everysecondtime=0;
 6aa:	d0 e0       	ldi	r29, 0x00	; 0
	statehandler = state_pwroff;
    
	/* The Main Loop */
	while (1) 
    {
 		if (millis()-hundrettwetyfifemstimer>125){
 6ac:	b4 de       	rcall	.-664    	; 0x416 <millis>
 6ae:	dc 01       	movw	r26, r24
 6b0:	cb 01       	movw	r24, r22
 6b2:	8c 19       	sub	r24, r12
 6b4:	9d 09       	sbc	r25, r13
 6b6:	ae 09       	sbc	r26, r14
 6b8:	bf 09       	sbc	r27, r15
 6ba:	8e 37       	cpi	r24, 0x7E	; 126
 6bc:	91 05       	cpc	r25, r1
 6be:	a1 05       	cpc	r26, r1
 6c0:	b1 05       	cpc	r27, r1
 6c2:	c0 f0       	brcs	.+48     	; 0x6f4 <main+0xa8>
			hundrettwetyfifemstimer = millis(); //set time immediately after loop call, therefore function is called every 125 ms
 6c4:	a8 de       	rcall	.-688    	; 0x416 <millis>
 6c6:	6b 01       	movw	r12, r22
 6c8:	7c 01       	movw	r14, r24
			if (everysecondtime > 0){
 6ca:	cc 23       	and	r28, r28
 6cc:	39 f0       	breq	.+14     	; 0x6dc <main+0x90>
				//process the data odd times
				ProcessData(p_myavgdata);
 6ce:	80 91 60 00 	lds	r24, 0x0060
 6d2:	90 91 61 00 	lds	r25, 0x0061
 6d6:	1e de       	rcall	.-964    	; 0x314 <ProcessData>
				everysecondtime=0;
 6d8:	cd 2f       	mov	r28, r29
 6da:	08 c0       	rjmp	.+16     	; 0x6ec <main+0xa0>
			}
			else{
				//handle states at even time
				statehandler(&stateflags);
 6dc:	e0 91 99 00 	lds	r30, 0x0099
 6e0:	f0 91 9a 00 	lds	r31, 0x009A
 6e4:	88 e9       	ldi	r24, 0x98	; 152
 6e6:	90 e0       	ldi	r25, 0x00	; 0
 6e8:	09 95       	icall
				everysecondtime++;
 6ea:	c1 2f       	mov	r28, r17
			}
			adc_enable();
 6ec:	37 9a       	sbi	0x06, 7	; 6
			MuxChannel(ANALOG1);
 6ee:	83 e0       	ldi	r24, 0x03	; 3
 6f0:	60 de       	rcall	.-832    	; 0x3b2 <MuxChannel>
			ADCSRA |= (1 << ADSC); //Start a ADC Measurement
 6f2:	36 9a       	sbi	0x06, 6	; 6
		} 
		//Reset Watchdog every loop
		wdt_reset();
 6f4:	a8 95       	wdr
    }
 6f6:	da cf       	rjmp	.-76     	; 0x6ac <main+0x60>

000006f8 <_exit>:
 6f8:	f8 94       	cli

000006fa <__stop_program>:
 6fa:	ff cf       	rjmp	.-2      	; 0x6fa <__stop_program>
